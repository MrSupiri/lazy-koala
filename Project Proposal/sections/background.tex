\section{Background}

\subsection{Cloud Computing}
With a emergence \ac{iaas} like \ac{aws} and \ac{gcp} there is big surge in organizations trying out source their computing needs third parties \citep{rimol_2021}. This is mainly due to elasticity given by all the all the cloud providers. Users can easily scale up and down there infrastructures within minutes without making any commitment and all the major providers bill users on what you use is what you pay model because cloud provider manage all the underlying infrastructure users doesn't have to worry about problems like hardware failures. In contract in a self hosted setting if user wanted at one extra GB of memory than what's available it require a lot of effort and cost to full fill that requirement.

\subsection{Cloud Native Applications}
During 90s and early 2000s all the application were made as big monolith from a single code base. Most of them were shipped as single binary. Since those days applications were fairly simple this worked very well with little to no downsides. But when 2010s came around there were lot of specialized frameworks and programming languages and marketing teams wanted lot of new futures quickly developed still maintaining reliability. But if the code base for \textbf{the} application was stored in a single repository, developers has to go though a long process to review and test if the changes won't break the currant system and developers are also limited by the framework and programming language initial develops chosen for the project.

To tackle these problems there was new way to develop applications were introduced, it's called "Microservices". Idea behind this concept to to break the all the functionalities of big monolith application to small individually scalable services and give a ownership of each service to small teams of people who work separately. With this flow developers are free to use whatever tool they like to develop each service. Because these services are developed parallelly by different teams this increases the development velocity by order of magnitude. \citep{Understa56:online}

As these services are relatively small and tailor made to run on cloud environments it's very easy to take something that's running on developers local machine to production cluster in matter of minutes. This is mainly thank to modern cloud native tools like CI/CD pipelines which automatically build and test the code for them, which can save lot of time spent just doing repetitive task which are prune to human errors. \citep{Whataret68:online}

\subsection{Monitoring Cloud Native Applications} \label{monitoring-bg}
Even though cloud native applications has lot to offer when it comes to developer velocity and productive, It has it's fair share of issues. Most of these problem are linked to sheer complexity of these systems and not having a properly way to monitor them \citep{5WaysYou35:online}. All 3 major cloud providers provides way to monitor these applications efficiently and there are some great open source projects that does this well, But to take the full advantage of those systems, developers have to adapt their services to export all the vitals in a way the monitoring system understand. This works for most part and this what all the big companies are doing, even if it takes more developer time to in the end it's very crucial when it comes disaster recovery.

But there is still slight problem with this approach. Once the system starts to scale up to 100s of services number vitals that has to be monitored goes to 1000s and will require lot of additional \acp{sres} and will have drop lot of non crucial service vitals and derive abstract \acp{sli} to make it \textbf{humanly} possible to understand what's going on.
